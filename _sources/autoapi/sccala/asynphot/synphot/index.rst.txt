sccala.asynphot.synphot
=======================

.. py:module:: sccala.asynphot.synphot


Classes
-------

.. autoapisummary::

   sccala.asynphot.synphot.BaseFilterCurve
   sccala.asynphot.synphot.FilterCurve
   sccala.asynphot.synphot.FilterSet
   sccala.asynphot.synphot.MagnitudeSet


Functions
---------

.. autoapisummary::

   sccala.asynphot.synphot.calculate_vega_zp
   sccala.asynphot.synphot.calculate_lambda_eff
   sccala.asynphot.synphot.calculate_vega_magnitude


Module Contents
---------------

.. py:function:: calculate_vega_zp(filter)

.. py:function:: calculate_lambda_eff(spec_wav, spec_flux, filter)

   Calculate effective wavelength from spectral flux.

   :param spec_wav: np.array of floats
       wavelength values of spectrum
   :param spec_flux: np.array of floats
       spectral flux
   :param filter: BaseFilter
       filter object on which the magnitude is to be calculated


.. py:function:: calculate_vega_magnitude(spec_wav, spec_flux, filter, spec_err=None, error_method='analytic', error_n=100)

   Calculate Vega magnitudes from spectral flux. If spectral uncertainties are
   supplied, a magnitude uncertainty will be calculated by propagating the
   uncertainty through the numerical integration (Simpson's rule).

   :param spec_wav: np.array of floats
       wavelength values of spectrum
   :param spec_flux: np.array of floats
       spectral flux
   :param filter: BaseFilter
       filter object on which the magnitude is to be calculated
   :param spec_err: np.array of floats or None
       spectral uncertainty. Default=None
   :param error_method: str
       method with which error is propagated. Default='analytic'
   :param error_n: int
       number of iteration for frequentist error propagation. Default=100
   :return vega_magnitude: np.array of floats
       calculated vega_magnitude
   :return vega_magnitude_error: np.array of floats, optional
       calculated magnitude uncertaint


.. py:class:: BaseFilterCurve(wav, trans, interpolation_kind='linear', filter_id=None)

   Bases: :py:obj:`object`


   .. py:method:: load_filter(filter_id=None, interpolation_kind='linear')
      :classmethod:



   .. py:attribute:: wav


   .. py:attribute:: trans


   .. py:attribute:: interpolation_object


   .. py:attribute:: filter_id
      :value: None



   .. py:method:: interpolate(wavelength)


   .. py:method:: calculate_vega_magnitude(spec_wav, spec_flux, spec_err=None)


   .. py:method:: calculate_lambda_eff(spec_wav, spec_flux)


.. py:class:: FilterCurve(wav, trans, interpolation_kind='linear', filter_id=None)

   Bases: :py:obj:`BaseFilterCurve`


   .. py:method:: __repr__()


.. py:class:: FilterSet(filter_set, interpolation_kind='linear')

   Bases: :py:obj:`object`


   .. py:method:: __iter__()


   .. py:method:: __next__()


   .. py:attribute:: next


   .. py:method:: __getitem__(item)


   .. py:method:: __repr__()


   .. py:method:: calculate_vega_magnitudes(spec_wav, spec_flux, spec_err=None)


   .. py:method:: calculate_lambda_effs(spec_wav, spec_flux)


.. py:class:: MagnitudeSet(filter_set, magnitudes, magnitude_uncertainties=None, interpolation_kind='linear')

   Bases: :py:obj:`FilterSet`


   .. py:attribute:: magnitudes


   .. py:method:: __repr__()


